---
title: "김영한의 자바 기초 강의 - part 10: 메서드"
pubDate: 2025-09-01
---

###메서드

## 메서드란?

자바에서는 함수를 **메서드**라고 부릅니다. 메서드는 입력값을 받아서 처리한 후 출력값을 반환하는 기능을 수행합니다. 간단히 말해, 특정 작업을 수행하는 코드 블록을 하나의 단위로 묶어놓은 것입니다.

## 메서드 사용의 장점

메서드를 사용하면 여러 가지 이점을 얻을 수 있습니다:

- **코드의 재사용성 향상**: 한 번 작성한 메서드를 여러 곳에서 반복 사용할 수 있습니다
- **코드의 가독성 향상**: 복잡한 로직을 의미 있는 이름의 메서드로 분리하여 코드를 이해하기 쉽게 만듭니다
- **모듈성 향상**: 기능별로 코드를 분리하여 구조화된 프로그램을 만들 수 있습니다
- **유지보수 용이성**: 특정 기능을 수정할 때 해당 메서드만 수정하면 됩니다
- **확장성 향상**: 새로운 기능을 추가하거나 기존 기능을 확장하기 쉬워집니다
- **추상화**: 복잡한 내부 구현을 숨기고 간단한 인터페이스만 제공합니다
- **테스트와 디버깅 용이성**: 각 메서드를 독립적으로 테스트하고 디버깅할 수 있습니다

## 메서드 선언 방법

메서드는 다음과 같은 형태로 선언합니다:

```java
public static int add(int a, int b) {
    return a + b;
}
```

메서드의 각 구성 요소를 살펴보면:

- `public`: 접근 제어자 (누구나 사용할 수 있음)
- `static`: 클래스 메서드 (객체 생성 없이 사용 가능)
- `int`: 반환 타입 (정수를 반환)
- `add`: 메서드 이름 (동사로 시작)
- `int a, int b`: 매개변수, 파라미터 (입력값)
- `{}`: 메서드 본문 (실제 로직이 들어가는 부분)
- `return a + b`: 반환 값 (결과를 반환)

**네이밍 규칙**:

- 변수명은 명사로 시작
- 메서드명은 동사로 시작

## 메서드 호출 방법

선언한 메서드는 다음과 같이 호출할 수 있습니다:

```java
int result = add(1, 2);
System.out.println(result);
```

여기서 `(1, 2)`는 **인수(인자)**라고 부릅니다. 메서드를 호출할 때는 인수의 값과 타입이 매개변수의 값과 타입과 정확히 맞아야 합니다.

또한 중요한 점은 메서드 호출이 끝나면 매개변수와 메서드 본문 내에서 사용된 변수들이 메모리에서 사라진다는 것입니다.

## 매개변수가 없는 메서드

매개변수가 필요 없는 메서드도 만들 수 있습니다:

```java
public static String printHello() {
    return "Hello";
}

String result = printHello();
```

이런 경우 매개변수 부분을 비워두고, 호출할 때도 인수를 전달하지 않습니다.

## 반환 타입이 없는 메서드

반환값이 필요 없는 메서드는 `void`를 사용합니다:

```java
public static void printHello(String name) {
    System.out.println("Hello " + name);
}

printHello("John");
```

`void` 메서드는 값을 반환하지 않으므로 호출할 때 반환값을 받을 변수를 선언하지 않습니다. 모든 메서드는 원칙적으로 `return`을 호출해야 하지만, `void` 타입인 경우 `return`을 생략할 수 있습니다.

## 반환 타입의 특징

반환 타입이 있는 메서드는 반드시 값을 반환해야 합니다. 그리고 `return`문을 만나면 메서드가 즉시 종료됩니다. 이는 메서드의 흐름 제어에 유용하게 사용할 수 있습니다.

## 메서드 값 전달의 특징

자바에서는 메서드에 값을 전달할 때 **값을 복사해서 전달**합니다. 이는 매우 중요한 개념입니다:

```java
int num = 10;
System.out.println(num);  // 10 출력
changeValue(num);
System.out.println(num);  // 여전히 10 출력

public static void changeValue(int num) {
    System.out.println(num);  // 10 출력
    num = 20;
    System.out.println(num);  // 20 출력
}
```

위 예제에서 `changeValue` 메서드 내부에서 `num`을 20으로 변경했지만, 원본 변수 `num`의 값은 여전히 10입니다. 이는 메서드에 전달된 값이 복사본이기 때문입니다.

만약 메서드를 통해 값을 변경하고 싶다면, 반환값을 받아서 변경해야 합니다:

```java
int num = 10;
System.out.println(num);  // 10 출력
num = changeValue(num);   // 반환값을 받아서 변경
System.out.println(num);  // 20 출력

public static int changeValue(int num) {
    System.out.println(num);  // 10 출력
    num = 20;
    System.out.println(num);  // 20 출력
    return num;  // 변경된 값을 반환
}
```

또한 메서드를 호출할 때 인자와 매개변수의 타입이 맞지 않으면 컴파일 에러가 발생합니다. 타입이 다르다면 형변환을 해야 합니다.

## 메서드 오버로딩

**메서드 오버로딩**은 같은 이름의 메서드를 매개변수만 다르게 하여 여러 개 정의하는 것입니다:

```java
public static int add(int a, int b) {
    return a + b;
}

public static int add(int a, int b, int c) {
    return a + b + c;
}
```

메서드 오버로딩이 가능한 조건:

- 매개변수의 타입이 다르거나
- 매개변수의 개수가 다르거나
- 매개변수의 순서가 다르면 가능

**주의사항**: 반환 타입만 다르면 메서드 오버로딩이 아닙니다. 반환 타입은 메서드를 구분하는 기준이 되지 않기 때문입니다.

## 메서드 시그니처

**메서드 시그니처**는 메서드를 구분할 수 있는 기준이 됩니다:

- **메서드 시그니처 = 메서드 이름 + 매개변수**
- 메서드 시그니처가 다르면 다른 메서드로 간주됩니다
- **반환 타입은 메서드 시그니처에 포함되지 않습니다**

이것이 바로 반환 타입만 다르면 메서드 오버로딩이 안 되는 이유입니다. 반환 타입만 다르면 같은 메서드로 간주하기 때문에 컴파일러가 메서드 호출 시점에 어떤 메서드를 호출할지 결정할 수 없기 때문입니다.

## Swift와의 차이점

| 특징              | Java                                  | Swift                                 |
| ----------------- | ------------------------------------- | ------------------------------------- |
| **함수 선언**     | `public static int add(int a, int b)` | `func add(_ a: Int, _ b: Int) -> Int` |
| **호출 방식**     | `add(1, 2)`                           | `add(1, 2)` 또는 `add(a: 1, b: 2)`    |
| **매개변수 라벨** | 없음                                  | 외부/내부 라벨 지원                   |
| **기본값**        | 지원 안함                             | `func greet(name: String = "World")`  |
| **반환값**        | 단일 값만                             | 튜플로 여러 값 반환 가능              |
| **오버로딩**      | 매개변수만 다르면 가능                | 매개변수만 다르면 가능                |
| **void**          | `void` 사용                           | `Void` 또는 반환 타입 생략            |

### Swift 함수 예시

**매개변수 라벨:**

```swift
func greet(to name: String) {
    print("Hello, \(name)!")  // 내부에서는 'name' 사용
}

greet(to: "Swift")  // 외부에서는 'to' 라벨 사용
```

**튜플로 여러 값 반환:**

```swift
func getMinMax(numbers: [Int]) -> (min: Int, max: Int) {
    let min = numbers.min() ?? 0
    let max = numbers.max() ?? 0
    return (min: min, max: max)
}

let result = getMinMax(numbers: [1, 5, 3, 9, 2])
print(result.min)  // 1
print(result.max)  // 9
```

### 주요 차이점

1. **Java의 메서드**는 클래스 내부에서만 정의 가능
2. **Swift의 함수**는 독립적으로도 정의 가능
3. **Java는 매개변수 라벨 없음**, **Swift는 라벨 지원**
4. **Java는 기본값 지원 안함**, **Swift는 기본값 설정 가능**
5. **Java는 단일 반환값**, **Swift는 튜플로 여러 값 반환**

---

## 느낀점

메서드를 학습하면서 Java와 Swift의 설계 철학 차이를 느낄 수 있었다.

### Java의 단순함과 명시성

Swift에서는 함수 호출 시 외부 라벨과 내부 라벨이 분리되어 있어 더 명확하게 호출할 수 있다는 장점이 있지만, 간단한 함수에서는 번거로워서 `_`를 자주 사용하게 된다. 반면 Java는 단순하게 `add(1, 2)` 형태로 호출할 수 있어서 더 직관적이라는 점이 인상적이었다.

### 메서드 시그니처의 엄격함

Java에서 반환 타입이 달라도 같은 메서드로 판별하는 것도 흥미로웠다. 이는 메서드 시그니처에 반환 타입이 포함되지 않기 때문인데, 컴파일러가 메서드 호출 시점에 어떤 메서드를 호출할지 결정할 수 없기 때문이다. 이런 엄격한 규칙이 Java의 타입 안정성을 보장한다는 것을 알게 되었다.

### 기본값 지원의 차이

Java에서 기본값을 지원하지 않는 이유는 단순성과 명시성, 타입 안정성을 위해서라는 점도 새로웠다. 하지만 최근 Java에서는 record를 사용하여 기본값도 제공한다는 것을 알게 되어, Java가 계속 끊임없이 발전하고 있다는 것을 느꼈다.

### 언어 설계 철학

Swift는 표현력을 중시하는 반면, Java는 명시성을 중시하는 것 같다. 각각의 장단점이 있지만, Java의 단순하고 명확한 문법이 큰 프로젝트에서 코드의 일관성을 유지하는 데 도움이 될 것 같다.
