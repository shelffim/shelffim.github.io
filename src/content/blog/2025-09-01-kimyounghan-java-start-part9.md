---
title: "김영한의 자바 기초 강의 - part 9"
pubDate: 2025-09-01
---

## 배열 (Array)

배열은 **같은 타입의 데이터를 연속된 메모리 공간에 저장**하는 자료구조입니다. 같은 타입의 변수를 반복해서 선언하고 사용하는 번거로움을 해결해주며, 효율적인 데이터 관리를 가능하게 합니다.

### 주요 개념

| 개념           | 설명                             | 중요도        |
| -------------- | -------------------------------- | ------------- |
| **배열**       | 같은 타입의 데이터를 연속 저장   | 데이터 관리   |
| **인덱스**     | 배열 요소의 위치를 나타내는 번호 | 요소 접근     |
| **참조값**     | 배열이 저장된 메모리 주소        | 메모리 관리   |
| **2차원 배열** | 배열의 배열 (행과 열 구조)       | 복잡한 데이터 |
| **for-each문** | 배열 순회를 위한 반복문          | 코드 간소화   |

---

## 1. 배열의 선언과 생성

### 배열 선언

배열을 사용하기 위해서는 먼저 배열 변수를 선언하고, 실제 배열을 생성해야 합니다.

```java
// 1단계: 배열 변수 선언
int[] numbers;

// 2단계: 배열 생성 (크기 지정)
numbers = new int[5];
```

### 배열 생성과 초기화

배열을 선언과 동시에 초기화할 수 있습니다.

```java
// 방법 1: 중괄호를 사용한 초기화
int[] numbers1 = {1, 2, 3, 4, 5};

// 방법 2: new 키워드와 함께 초기화
int[] numbers2 = new int[] {1, 2, 3, 4, 5};

// 방법 3: 크기만 지정 (기본값으로 초기화)
int[] numbers3 = new int[5]; // {0, 0, 0, 0, 0}
```

### 배열의 기본값

배열 생성 시 각 타입별 기본값이 자동으로 설정됩니다.

| 타입     | 기본값 |
| -------- | ------ |
| `int`    | `0`    |
| `double` | `0.0`  |
| `String` | `null` |

### 핵심 포인트

- **배열 변수**: 배열의 참조값(주소)을 저장
- **배열 생성**: `new` 키워드로 실제 메모리 공간 할당
- **크기 고정**: 배열 생성 후 크기 변경 불가
- **타입 일치**: 모든 요소는 같은 타입이어야 함

---

## 2. 인덱스와 배열 접근

### 인덱스란?

**인덱스**는 배열의 각 요소 위치를 나타내는 번호입니다.

```java
int[] numbers = {10, 20, 30, 40, 50};

// 인덱스를 사용한 값 대입
numbers[0] = 100;  // 첫 번째 요소
numbers[1] = 200;  // 두 번째 요소

// 인덱스를 사용한 값 사용
System.out.println(numbers[0]);  // 100
System.out.println(numbers[1]);  // 200
```

### 인덱스 규칙

- **시작 인덱스**: 0부터 시작
- **마지막 인덱스**: 배열 크기 - 1
- **범위**: 0 ~ (배열 크기 - 1)

```java
int[] numbers = new int[5];  // 크기 5

// 유효한 인덱스: 0, 1, 2, 3, 4
numbers[0] = 10;  // ✅ 유효
numbers[4] = 50;  // ✅ 유효
// numbers[5] = 60;  // ❌ ArrayIndexOutOfBoundsException
```

### 배열 길이 확인

```java
int[] numbers = {1, 2, 3, 4, 5};
System.out.println("배열 길이: " + numbers.length);  // 5

// 배열의 마지막 요소 접근
int lastIndex = numbers.length - 1;
System.out.println("마지막 요소: " + numbers[lastIndex]);  // 5
```

### 핵심 포인트

- **0부터 시작**: 첫 번째 요소의 인덱스는 0
- **범위 주의**: 유효한 인덱스 범위를 벗어나면 오류 발생
- **length 속성**: `배열변수.length`로 배열 크기 확인
- **마지막 인덱스**: `배열변수.length - 1`

---

## 3. 참조형 vs 기본형

### 참조값 저장의 이유

배열 변수는 **참조값(주소)**을 저장하는 이유가 있습니다.

```java
// 기본형 변수
int number = 10;  // 값 자체를 저장

// 참조형 변수 (배열)
int[] numbers = new int[5];  // 배열의 주소를 저장
```

### 기본형 vs 참조형 비교

| 특징            | 기본형       | 참조형 (배열)        |
| --------------- | ------------ | -------------------- |
| **저장 방식**   | 값 자체 저장 | 참조값(주소) 저장    |
| **메모리 크기** | 선언 시 결정 | 런타임에 결정        |
| **크기 변경**   | 불가능       | 불가능 (배열은 고정) |
| **유연성**      | 제한적       | 높음 (동적 할당)     |

### 참조값의 장점

```java
// 배열의 참조값을 다른 변수에 할당
int[] original = {1, 2, 3, 4, 5};
int[] copy = original;  // 같은 배열을 참조

copy[0] = 100;
System.out.println(original[0]);  // 100 (같은 배열이므로 변경됨)
```

### 핵심 포인트

- **기본형**: 값 자체를 메모리에 저장
- **참조형**: 객체나 배열의 주소를 저장
- **유연성**: 참조값을 통해 동적 메모리 관리
- **공유**: 같은 참조값을 가진 변수들은 같은 객체를 공유

---

## 4. 2차원 배열

### 2차원 배열이란?

**2차원 배열**은 배열의 배열로, 행과 열로 구성된 표 형태의 데이터 구조입니다.

```java
// 2차원 배열 선언과 생성
int[][] array = new int[2][3];  // 2행 3열
```

### 2차원 배열 초기화

```java
// 방법 1: 중괄호를 사용한 초기화
int[][] array1 = {
    {1, 2, 3},
    {4, 5, 6}
};

// 방법 2: new 키워드와 함께 초기화
int[][] array2 = new int[][] {
    {1, 2, 3},
    {4, 5, 6}
};
```

### 2차원 배열 접근

```java
int[][] array = {
    {1, 2, 3},
    {4, 5, 6}
};

// 요소 접근: array[행][열]
System.out.println(array[0][0]);  // 1 (첫 번째 행, 첫 번째 열)
System.out.println(array[1][2]);  // 6 (두 번째 행, 세 번째 열)

// 값 변경
array[0][1] = 100;
System.out.println(array[0][1]);  // 100
```

### 2차원 배열 길이

```java
int[][] array = {
    {1, 2, 3},
    {4, 5, 6}
};

System.out.println("행의 개수: " + array.length);        // 2
System.out.println("첫 번째 행의 열 개수: " + array[0].length);  // 3
```

### 핵심 포인트

- **행과 열**: `array[행][열]` 형태로 접근
- **배열의 배열**: 각 행이 하나의 배열
- **길이 확인**: `array.length` (행), `array[0].length` (열)
- **표 형태**: 행렬이나 표 데이터를 표현할 때 유용

---

## 5. for-each문 (향상된 for문)

### for-each문이란?

**for-each문**은 배열이나 컬렉션의 모든 요소를 순회할 때 사용하는 간편한 반복문입니다.

```java
int[] numbers = {1, 2, 3, 4, 5};

// for-each문 사용
for (int num : numbers) {
    System.out.println(num);
}
```

**출력 결과:**

```
1
2
3
4
5
```

### for-each문 vs 일반 for문

```java
int[] numbers = {1, 2, 3, 4, 5};

// 일반 for문 (인덱스 사용)
for (int i = 0; i < numbers.length; i++) {
    System.out.println("인덱스 " + i + ": " + numbers[i]);
}

// for-each문 (값만 사용)
for (int num : numbers) {
    System.out.println("값: " + num);
}
```

### for-each문의 특징

```java
int[] numbers = {1, 2, 3, 4, 5};

// for-each문으로 값 변경 시도 (변경되지 않음)
for (int num : numbers) {
    num = num * 2;  // 원본 배열은 변경되지 않음
}

// 원본 배열 출력
for (int num : numbers) {
    System.out.println(num);  // 1, 2, 3, 4, 5 (변경되지 않음)
}
```

### for-each문으로 값 변경이 안 되는 이유

**for-each문의 변수는 배열 요소의 복사본**이기 때문에 원본 배열을 변경할 수 없습니다.

```java
int[] numbers = {1, 2, 3, 4, 5};

// for-each문은 내부적으로 다음과 같이 동작
for (int num : numbers) {
    // num은 numbers[i]의 복사본
    num = 100;  // 복사본만 변경, 원본은 그대로
}

// 일반 for문은 인덱스로 배열의 실제 위치에 직접 접근
for (int i = 0; i < numbers.length; i++) {
    numbers[i] = 100;  // 원본 배열 직접 변경
}
```

### 언제 사용할까?

| 상황            | 사용할 반복문 | 이유               |
| --------------- | ------------- | ------------------ |
| **값만 읽기**   | for-each문    | 간단하고 안전      |
| **인덱스 필요** | 일반 for문    | 인덱스 접근 가능   |
| **값 변경**     | 일반 for문    | 인덱스로 직접 접근 |

### 핵심 포인트

- **간편함**: 인덱스 관리 불필요
- **안전함**: 배열 범위 초과 오류 방지
- **읽기 전용**: 값 변경 시에는 일반 for문 사용
- **가독성**: 코드가 더 간결하고 이해하기 쉬움

---

## Swift와의 차이점

| 특징            | Java                      | Swift                           |
| --------------- | ------------------------- | ------------------------------- |
| **배열 선언**   | `int[] numbers`           | `var numbers: [Int]`            |
| **배열 생성**   | `new int[5]`              | `[Int](repeating: 0, count: 5)` |
| **배열 초기화** | `{1, 2, 3}`               | `[1, 2, 3]`                     |
| **배열 길이**   | `numbers.length`          | `numbers.count`                 |
| **for-each문**  | `for (int num : numbers)` | `for num in numbers`            |
| **크기 변경**   | 불가능                    | 가능 (동적 배열)                |

### 주요 차이점

1. **Java의 배열**은 크기가 고정되어 변경 불가능
2. **Swift의 배열**은 동적 배열로 크기 변경 가능
3. **Java는 참조값 저장**, **Swift는 값 타입**
4. **Java의 for-each문**은 `:` 사용, **Swift는 `in` 사용**
5. **Java는 `length`**, **Swift는 `count` 사용**

---

## 느낀 점

배열을 학습하면서 Java의 배열이 Swift보다 더 엄격하다는 것을 알게 되었다. 특히 Java의 배열은 크기가 고정되어 한 번 생성하면 변경할 수 없지만, Swift의 배열은 동적으로 크기를 변경할 수 있다는 차이점이 인상적이었다.

for-each문의 경우 Java와 Swift 모두 비슷한 개념이지만 문법이 다르다는 점도 흥미로웠다. for-each문은 복사본을 사용하기 때문에 값 변경이 안 된다는 사실도 새로웠다.

참조값 저장에 대한 개념도 새로웠는데, 배열 변수가 실제 데이터가 아닌 메모리 주소를 저장한다는 것이 처음에는 이해하기 어려웠지만, 이를 통해 메모리 효율성과 유연성을 제공한다는 점을 배웠다.
